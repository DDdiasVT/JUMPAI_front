from fastapi import FastAPI, UploadFile, File, HTTPException, Form
from fastapi.middleware.cors import CORSMiddleware
from tempfile import NamedTemporaryFile
from functools import lru_cache 
import os
import cv2
import mediapipe as mp
import numpy as np
import requests
from google import genai
import gc
import base64
import subprocess # Para rodar o FFmpeg

# --- CONFIGURA√á√ïES ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY") 
GOOGLE_FORM_URL = "https://docs.google.com/forms/d/e/1FAIpQLScqve9FcZhMQkakXLGfnEiJzyKWAN8cLqaMCiLvRHez9NQYmg/formResponse"
LINK_INFINITEPAY = "https://link.infinitepay.io/digmkt/VC1DLTItSQ-2GSZhOK9Ep-17,00"

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils

@lru_cache(maxsize=1)
def get_pose_model():
    return mp_pose.Pose(min_detection_confidence=0.7, min_tracking_confidence=0.7, model_complexity=1)

def calcular_angulo(a, b, c):
    a = np.array(a); b = np.array(b); c = np.array(c)
    radians = np.arctan2(c[1]-b[1], c[0]-b[0]) - np.arctan2(a[1]-b[1], a[0]-b[0])
    angle = np.abs(radians*180.0/np.pi)
    if angle > 180.0: angle = 360-angle
    return angle

def salvar_lead(dados_contato, dados_metricas, plano_texto):
    dados = {
        "entry.1427267338": dados_contato['nome'],
        "entry.597277093": dados_contato['email'],
        "entry.1793364676": dados_contato['telefone'],
        "entry.215882622": str(dados_contato['altura_user']),
        "entry.1994800528": f"{dados_metricas['altura']:.1f}",
        "entry.1509204305": f"{dados_metricas['dip']:.0f}",
        "entry.1858263009": f"{dados_metricas['extensao']:.0f}",
        "entry.635471438": f"{dados_metricas['tempo']:.2f}",
        "entry.1582150062": plano_texto
    }
    try:
        requests.post(GOOGLE_FORM_URL, data=dados)
        return True
    except:
        return False

def gerar_plano_gemini(dados_contato, dados_metricas):
    if not GEMINI_API_KEY: return "Erro: Chave API n√£o configurada."
    try:
        client = genai.Client(api_key=GEMINI_API_KEY)
        dados_str = f"Atleta: {dados_contato['nome']}, Salto: {dados_metricas['altura']:.1f}cm, Dip: {dados_metricas['dip']:.0f}, Ritmo: {dados_metricas['tempo']:.2f}s"
        prompt = f"""
        ATUA√á√ÉO: Voc√™ √© um treinador ol√≠mpico de for√ßa e condicionamento, especialista em biomec√¢nica de salto vertical.
        
        DADOS DO ATLETA ANALISADO:
        {dados_str}
        
        TAREFA:
        Analise os dados biomec√¢nicos acima e crie um relat√≥rio de alta performance.
        
        ESTRUTURA OBRIGAT√ìRIA DA RESPOSTA:
        
        1. ü©∫ DIAGN√ìSTICO T√âCNICO (Seja direto):
           - Analise o DIP: Est√° muito profundo (>100) ou curto (<80)? Explique o impacto disso.
           - Analise o RITMO: Est√° lento (>0.8s)? Isso indica falta de for√ßa reativa?
           - D√™ um feedback sobre a extens√£o.
           
        2. üéØ A META DE 30 DIAS:
           - Projete um ganho realista em cm se ele seguir o treino (ex: +3 a 5cm).
           
        3. üìÖ O PLANO DE A√á√ÉO DE 4 SEMANAS (Obrigat√≥rio):
           Crie uma rotina pr√°tica dividida por semanas.
           - Semana 1: Foco (ex: T√©cnica de Aterrissagem e For√ßa Base). Liste 3 exerc√≠cios.
           - Semana 2: Foco (ex: Pot√™ncia e Pliometria Baixa). Liste 3 exerc√≠cios.
           - Semana 3: Foco (ex: Reatividade e Choque). Liste 3 exerc√≠cios.
           - Semana 4: Foco (ex: Deload e Teste M√°ximo).
           
        IMPORTANTE: N√£o use asteriscos (**) para negrito, use CAIXA ALTA para destaques. Seja motivador e use emojis.
        """
        
        response = client.models.generate_content(model="gemini-2.5-flash", contents=prompt)
        return response.text
    except Exception as e:
        return f"Erro Gemini: {str(e)}"

# --- CONVERS√ÉO DE V√çDEO (FIX PARA NAVEGADORES) ---
def converter_para_h264(input_path, output_path):
    """Usa FFmpeg para converter o v√≠deo para H.264 (compat√≠vel com navegadores)"""
    try:
        # Comando FFmpeg para converter para MP4 H.264 leve
        command = [
            'ffmpeg', '-y', # Sobrescrever
            '-i', input_path,
            '-vcodec', 'libx264',
            '-f', 'mp4',
            '-preset', 'fast', # R√°pido
            '-crf', '28', # Compress√£o maior para arquivo leve
            output_path
        ]
        subprocess.run(command, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except Exception as e:
        print(f"Erro FFmpeg: {e}")
        return False

# --- PROCESSAMENTO COM V√çDEO ---
def processar_video(video_path):
    pose = get_pose_model()
    cap = cv2.VideoCapture(video_path)
    
    largura = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    altura = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = cap.get(cv2.CAP_PROP_FPS)
    if fps == 0 or np.isnan(fps): fps = 30.0
    
    # Reduzir resolu√ß√£o para 480p (mais r√°pido e leve)
    fator = 480 / largura if largura > 480 else 1.0
    largura_nova = int(largura * fator)
    altura_nova = int(altura * fator)

    # Arquivo tempor√°rio RAW (antes da convers√£o)
    tfile_raw = NamedTemporaryFile(delete=False, suffix='.avi')
    raw_path = tfile_raw.name
    
    # Usamos MJPG para garantir escrita r√°pida no Linux
    fourcc = cv2.VideoWriter_fourcc(*'MJPG')
    out = cv2.VideoWriter(raw_path, fourcc, fps, (largura_nova, altura_nova))

    chao_y = 0; min_dip = 180; max_ext = 0; frames_ar = 0; estado = "CHAO"
    frame_idx = 0; frame_takeoff = 0; frame_dip = 0; altura_cm = 0.0
    
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret: break
        
        if fator != 1.0: frame = cv2.resize(frame, (largura_nova, altura_nova))
        
        image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        res = pose.process(image_rgb)

        if res.pose_landmarks:
            mp_drawing.draw_landmarks(
                frame, 
                res.pose_landmarks, 
                mp_pose.POSE_CONNECTIONS,
                mp_drawing.DrawingSpec(color=(245,117,66), thickness=2, circle_radius=2),
                mp_drawing.DrawingSpec(color=(245,66,230), thickness=2, circle_radius=2)
            )

            lms = res.pose_landmarks.landmark
            h = [lms[23].x, lms[23].y]; k = [lms[25].x, lms[25].y]; a = [lms[27].x, lms[27].y]
            pe_y = max(lms[31].y, lms[32].y) * altura_nova
            ang_joelho = calcular_angulo(h, k, a)

            if estado == "CHAO":
                if frame_idx < 15: pass 
                elif chao_y == 0: chao_y = pe_y 
                if chao_y > 0:
                    if ang_joelho < min_dip: min_dip = ang_joelho
                    if ang_joelho < 170 and frame_dip == 0: frame_dip = frame_idx
                    if pe_y < (chao_y - altura_nova * 0.03): 
                        estado = "AR"; frame_takeoff = frame_idx
            elif estado == "AR":
                frames_ar += 1
                if ang_joelho > max_ext: max_ext = ang_joelho
                if pe_y >= (chao_y - altura_nova * 0.01):
                    estado = "POUSO"
                    tempo_voo = frames_ar / fps 
                    altura_cm = 122.6 * (tempo_voo ** 2)

        out.write(frame)
        frame_idx += 1
        if frame_idx % 50 == 0: gc.collect()

    cap.release()
    out.release()
    
    tempo_dip = (frame_takeoff - frame_dip) / fps if frame_dip > 0 else 0
    
    return {
        "metricas": {"altura": altura_cm, "dip": min_dip, "extensao": max_ext, "tempo": tempo_dip},
        "raw_path": raw_path
    }

@app.get("/")
def home(): return {"status": "IA Online"}

@app.post("/analisar_salto/")
async def analisar(
    video: UploadFile = File(...),
    nome: str = Form(...),
    email: str = Form(...),
    telefone: str = Form(...),
    altura_user: float = Form(...)
):
    tmp_path = None
    raw_path = None
    final_mp4_path = None
    
    try:
        with NamedTemporaryFile(delete=False, suffix='.mp4') as tmp:
            tmp.write(await video.read())
            tmp_path = tmp.name
        
        # 1. Processa e gera v√≠deo RAW
        resultado = processar_video(tmp_path)
        metricas = resultado["metricas"]
        raw_path = resultado["raw_path"]
        
        # 2. Converte RAW para H.264 (Navegador)
        final_mp4_path = raw_path.replace('.avi', '_final.mp4')
        conversao_ok = converter_para_h264(raw_path, final_mp4_path)
        
        if conversao_ok:
            with open(final_mp4_path, "rb") as video_file:
                video_base64 = base64.b64encode(video_file.read()).decode('utf-8')
        else:
            video_base64 = None # Se falhar, retorna sem v√≠deo mas com dados

        contato = {'nome': nome, 'email': email, 'telefone': telefone, 'altura_user': altura_user}
        plano = gerar_plano_gemini(contato, metricas)
        salvar_lead(contato, metricas, plano)

        return {
            "status": "ok", 
            "metricas": metricas, 
            "plano": plano,
            "link_pagamento": LINK_INFINITEPAY,
            "video_base64": video_base64
        }

    except Exception as e:
        print(f"Erro: {e}") 
        raise HTTPException(500, detail=str(e))
    finally:
        # Limpeza
        for p in [tmp_path, raw_path, final_mp4_path]:
            if p and os.path.exists(p): os.unlink(p)
